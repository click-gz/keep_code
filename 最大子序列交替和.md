#  最大子序列交替和

一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。

比方说，数组 [4,2,5,3] 的交替和为 (4 + 5) - (2 + 3) = 4 。
给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 （子序列的下标 重新 从 0 开始编号）。

一个数组的 子序列 是从原数组中删除一些元素后（也可能一个也不删除）剩余元素不改变顺序组成的数组。比方说，[2,7,4] 是 [4,2,3,7,2,1,4] 的一个子序列（加粗元素），但是 [2,4,2] 不是。

示例 1：

输入：nums = [4,2,5,3]
输出：7
解释：最优子序列为 [4,2,5] ，交替和为 (4 + 5) - 2 = 7 。
示例 2：

输入：nums = [5,6,7,8]
输出：8
解释：最优子序列为 [8] ，交替和为 8 。
示例 3：

输入：nums = [6,2,1,2,4,5]
输出：10
解释：最优子序列为 [6,1,5] ，交替和为 (6 + 5) - 1 = 10 。


提示：

1 <= nums.length <= 105
1 <= nums[i] <= 105

```c++
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) {
        long long int f[nums.size() + 1], g[nums.size() + 1];
        f[0] = 0;//奇数
        g[0] = 0;//偶数
        for(int i = 0; i < nums.size(); i++)
        {
            f[i+1] = max(f[i], g[i] - nums[i]);
            g[i+1] = max(g[i], f[i] + nums[i]);
        }
        return max(g[nums.size()], f[nums.size()]);

    }
};

//动态规划：总序列分成小序列，求解从前到后子序列目前最优解
//f：当前元素放在前面子序列奇数位置最优解
//g: 当前元素放在前面子序列偶数位置最优解
//当前元素之前子序列最优解为：奇数位置（max(偶数位置-当前，之前奇数位置)）；偶数位置（max(奇数位置+当前，之前偶位置)）
```

